
/**
 * Arithmetic II
 *
 * @Description
 * Please use the class "BigDecimal" you wrote to redo the Arithmetic problem you did last week.
 * All the rules are the same as the Arithmetic problem in the last week.
 *
 * @Input Description
 * Expressions end up with line-break or end-of-file.
 *
 * @Output Description
 * Result of the expression to the 2nd decimal place, "ERROR" when parentheses count does not match or operation error, ending with a "\n" of each line
 */
#include <bits/stdc++.h>
#define Bu
#define Accuracy 16
using namespace std;
template<class T>

class Node
{
private:
    Node<T> *prev;
    Node<T> *next;
    T data;
public:
    Node(): data(0), prev(NULL), next(NULL) {}
    Node(T _data): data(_data), prev(NULL), next(NULL) {}
    Node(T _data, Node<T> *_prev, Node<T> *_next): data(_data), prev(_prev), next(_next) {}
    T get_data () const
    {
        return data;
    }
    void set_data (T d)
    {
        data = d;
    }
    Node<T> *get_prev () const
    {
        return (Node<T> *)prev;
    }
    void set_prev (Node<T> *p)
    {
        prev = p;
    }
    Node<T> *get_next () const
    {
        return (Node<T> *)next;
    }
    void set_next (Node<T> *n)
    {
        next = n;
    }
    void show () const
    {
        cout << "data: "<<data<<endl;
        if (prev != NULL)
            cout<<"prev: "<<prev<<endl;
        else
            cout<<"prev: NULL"<<endl;
        if (next != NULL)
            cout<<"next: "<<next<<endl;
        else
            cout<<"next: NULL"<<endl;
    }
};

template<class T>
class LinkedList
{
private:
    Node<T> *head;
    Node<T> *tail;
    int many;
public:
    LinkedList(): head(NULL), tail(NULL), many(0) {}
    void addToTail(T d)
    {
        Node<T> *tmp = new Node<T>(d);
        if (tail == NULL)
        {
            head = tail = tmp;
            many ++;
            return;
        }
        tail->set_next(tmp);
        tmp->set_prev(tail);
        tail = tmp;
        many ++;
    }
    void addToHead(T d)
    {
        Node<T> *tmp = new Node<T>(d);
        if (head == NULL)
        {
            tail = head = tmp;
            return;
        }
        head->set_prev(tmp);
        tmp->set_next(head);
        head = tmp;
        many ++;
    }
    bool addToNext (Node<T> *at, T d)
    {
        Node<T> *tmp;
        for (tmp=head; tmp != NULL && tmp != at; tmp = tmp->get_next());
        if (tmp == NULL) //不在串列中
            return false;
        if (tmp == tail) //沒有後一個
        {
            addToTail(d);
            many ++;
            return true;
        }
        tmp = new Node<T>(d);
        tmp->set_prev(at);
        tmp->set_next(at->get_next());
        at->set_next(tmp);
        (tmp->get_next())->set_prev(tmp);
        many ++;
        return true;
    }
    Node<T> *deleteFromHead ()
    {
        if (head == NULL) //沒東西可刪
            return NULL;
        Node<T> *tmp = head;
        head = head->get_next();
        if (head == NULL) //刪的是最後一個
        {
            tail = NULL;
            many --;
            return tmp;
        }
        tmp->set_next(NULL);
        head->set_prev(NULL);
        many --;
        return tmp;
    }
    Node<T> *deleteFromTail ()
    {
        if (tail == NULL)
            return NULL;
        Node<T> *tmp = tail;
        tail = tail->get_prev();
        if (tail == NULL)
        {
            head = NULL;
            many --;
            return tmp;
        }
        tmp->set_prev(NULL);
        tail->set_next(NULL);
        many --;
        return tmp;
    }
    Node<T> *deleteFromMiddle (Node<T> *at)
    {
        Node<T> *tmp;
        for (tmp=head; tmp->get_next() != NULL && tmp->get_next() != at; tmp = tmp->get_next());
        if (tmp->get_next() == NULL) //不在串列中
            return NULL;
        tmp->set_next(at->get_next());
        (at->get_next())->set_prev(tmp);
        at->set_prev(NULL);
        at->set_next(NULL);
        many --;
        return at;
    }
    void deleteData(T d)
    {
        Node<T> *tmp;
        for (tmp = head; tmp != NULL && tmp->get_data() != d; tmp = tmp->get_next());
        if (tmp != NULL)
        {
            if (tmp == head)
                deleteFromHead();
            else if (tmp == tail)
                deleteFromTail();
            else
                deleteFromMiddle(tmp);
        }
    }
    void deleteData(T d, int n)
    {
        Node<T> *tmp = head, *at;
        while (n > 0 && tmp != NULL)
        {
            for (; tmp != NULL && tmp->get_data() != d; tmp = tmp->get_next());
            if (tmp != NULL)
            {
                at = tmp;
                tmp = tmp->get_next();
                if (at == head)
                    deleteFromHead();
                else if (at == tail)
                    deleteFromTail();
                else
                    deleteFromMiddle(at);
                n--;
            }
        }
    }
    Node<T> *get_head () const
    {
        return (Node<T> *)head;
    }
    Node<T> *get_tail () const
    {
        return (Node<T> *)tail;
    }
    friend std::ostream &operator<<(std::ostream &out, LinkedList * n)
    {
        Node<T> *tmp;
        out << "(";
        for (tmp=n->get_head(); tmp != n->get_tail() ; tmp = tmp->get_next())
            out << tmp->get_data()<<", ";
        out << tmp->get_data()<< ")\n";
    }
    int get_many () const
    {
        return many;
    }
};

template<class T>
class Stack
{
private:
    LinkedList<T> *list;
public:
    Stack()
    {
        list = new LinkedList<T>;
    }
    void push(T data)
    {
        list->addToTail(data);
    }
    T pop()
    {
        if (list->get_tail() != NULL)
            return list->deleteFromTail()->get_data();
        throw invalid_argument("is empty");
    }
    T top()
    {
        if (list->get_tail() != NULL)
            return list->get_tail()->get_data();
        throw invalid_argument("is empty");
    }
    bool isEmpty()
    {
        if (list->get_tail() == NULL)
            return true;
        return false;
    }
    int size()
    {
        return list->get_many();
    }
    void show () const
    {
        Node<T> *tmp;
        cout << "Stack:\n";
        for (tmp=list->get_head(); tmp != NULL; tmp = tmp->get_next())
            cout << tmp->get_data() << " ";
        cout << "\n";
    }
};

class Formula
{
public:
    static string calculate_p_d (string lv, string rv, bool b=true)
    {
        // exp(b * ln(a)) = exp(ln(C)) --> exp(b * ln(a)) = C = a^b
        if (lv == "0" || lv[0] == '-')
            throw invalid_argument("");
        else if (rv[0] == '-') //   a ^ -b --> 1 / a ^ b
            return calculate_d ("1", calculate_p_d (lv, calculate_s ("0", rv, false), false));
        string tmp="1";//, i="1"
        /*printf ("       In calculate_p_d:\n");
        cout << "lv: " << lv << "\nrv: " << rv << "\n\n";*/
        int r_dot = rv.find('.');
        if (r_dot != -1)
        {
            tmp = calculate_p_i (lv, string(rv.substr(0, r_dot)));
            rv = rv.substr(r_dot);
            rv.insert (0, "0");
        }
       // printf ("       after if (r_dot != -1):\n");
       // cout << "lv: " << lv << "\nrv: " << rv <<"\ntmp: " << tmp << "\n\n";
        tmp = calculate_m (tmp, exponential (calculate_m (rv, nature_log (lv), false)), false);
       // cout << "tmp: " << tmp << "\n\n";
        if (b)
            return rounding (tmp);
        else
            return tmp;
    }
    static string nature_log (string v) //  t = (x-1) / (x+1)
    {
        //   ln(x) = 2t * (  1 + t^2/3  +  t^4/5  + t^6/7 + .... )
       // printf ("       In nature_log\n");
        string tmp="1", c, t, n, n_1;
        int x;
        t = calculate_d (calculate_s (v, "1", false), calculate_a (v, "1", false), false, Accuracy);
       /* cout << "v: " << v << "\n";
        cout << "t: " << t << "\n\n";*/
        for (c="2", n=t, n_1="", tmp="1" ;  ;  c = calculate_a (c, "2"))
        {
            n_1 = calculate_d (calculate_p_i (t, c, false), calculate_a (c, "1"), false, Accuracy);
            /*cout << "c: " << c << "\n";
            cout << "n_1: " << n_1 << "\n";
            cout << "n: " << n << "\n";
            cout << "n-n_1: " << calculate_s (n, n_1, false) << "\n";*/
            if (VS (calculate_s (n, n_1, false), "0.0000000000000001") < 0)
            {
                break;
            }
            tmp = calculate_a (tmp, n_1, false);
            n = n_1;
          // cout << "tmp: " << tmp << "\n\n";
        }
     /*  cout << "tmp: " << tmp << "\n\n";
        printf ("       Out nature_log\n\n");*/
        return calculate_m (calculate_m (t, "2", false), tmp, false);
    }
    static string exponential (string v)
    {
        // exp(v) = 1 + v + v^2/2! + v^3/3! + ...
      //  printf ("       In exponential\n");
        v = move_zero_d (v);
      //  cout << "v: " << v << "\n\n";
        string tmp = "", c, n, n_1;
        tmp = calculate_a ("1", v, false); // 1 + v
       // cout << "tmp: " << tmp << "\n\n";
        for (c = "2", n=v, n_1="" ; ; c = calculate_a (c, "1"))
        {
            n_1 = calculate_d (calculate_p_i (v, c, false), order (c), false, Accuracy);
           /* cout << "c: " << c << "\n";
            cout << "n_1: " << n_1 << "\n";
            cout << "n: " << n << "\n";
            cout << "n-n_1: " << calculate_s (n, n_1, false) << "\n";*/
            if (VS (calculate_s (n, n_1, false), "0.0000000000000001") < 0)
                break;
            tmp = calculate_a (tmp, n_1, false);
            n = n_1;
            //cout << "tmp: " << tmp << "\n\n";
        }
        /*cout << "tmp: " << tmp << "\n\n";
        printf ("       End exponential\n");*/
            return rounding (tmp, Accuracy);
    }
    static string order (string v) // v! == v * v-1 * v-2 * ... * 1
    {
       // printf ("       In order\n");
        if (v.find (".") != -1)
            return "";
        //cout << "v: " << v << "\n";
        string tmp = "1", c;
        for (c = v ; VS (c, "0.00") > 0 ; c = calculate_s (c, "1"))
            tmp = calculate_m (tmp, c, false);
       /* cout << "tmp: " << tmp << "\n\n";
        printf ("       End order\n");*/
        return tmp;
    }
    static string calculate_p_i (string lv, string rv, bool b=true)
    {
        clear_vstring (&lv, &rv);
        if (lv == "")
            lv = "0";
        if (rv == "")
            rv = "0";
        if (lv == "0")
            throw invalid_argument("");
        else if (rv == "0")
            return "1";
        else if (rv[0] == '-') //   a ^ -b --> 1 / a ^ b
            return calculate_d ("1", calculate_p_i (lv, calculate_s ("0", rv, false), false));
        else if (lv[0] == '-' && (rv[rv.size()-1]-48)%2 == 1) //-a ^ b  b是基數 --> - (a ^ b)
            return calculate_s ("0", calculate_p_i (calculate_s ("0", lv, false), rv));
        else if (lv[0] == '-' && (rv[rv.size()-1]-48)%2 == 0) //-a ^ b  b是偶數 -->   (a ^ b)
            return calculate_p_i (calculate_s ("0", lv, false), rv);
        string tmp="", c="";
        int x, y, z;
        for (c="0", tmp="1" ; VS (c, rv) < 0 ; c = calculate_a (c, "1"))
        {
            tmp = calculate_m (tmp, lv, false);
            //cout << "tmp (in while): " << tmp << "\n";
        }
        if (b)
            return rounding (tmp);
        else
            return rounding (tmp, Accuracy);
    }
    static string calculate_m (string lv, string rv, bool b=true)
    {
        clear_vstring (&lv, &rv);
        if (lv == "")
            lv = "0";
        if (rv == "")
            rv = "0";
       /*cout << "lv: "<< lv<<"\n";
        cout << "rv: "<< rv<<"\n";*/
        if (lv == "0" || rv == "0")
            return "0";
        else if (lv == "-")
            return calculate_s ("0", rv, b);
        else if ((lv[0] == '-' && rv[0] != '-') || (lv[0] != '-' && rv[0] == '-')) // -a * b || a * -b --> -(a * b)
            return calculate_s ("0", calculate_m(calculate_s("0", lv, false), rv), b);
        else if (lv[0] == '-' && rv[0] == '-') // -a * -b --> a * b
            return calculate_m (calculate_s("0", lv, false), calculate_s("0", rv, false), b);
        string tmp="", c="";
        int l_dot = lv.find('.'), r_dot = rv.find('.'), dot=0, x, y, z, m, k, d;
        if (l_dot != -1)
            dot += lv.size() - l_dot - 1;
        if (r_dot != -1)
            dot += rv.size() - r_dot - 1;
        if (lv.size() > rv.size())
            rv = add_i_zero (rv, lv.size()-rv.size());
        else if (lv.size() < rv.size())
            lv = add_i_zero (lv, rv.size()-lv.size());
        /**********運算********************/
        for (x=lv.size()-1, d=0, k=0; x >= 0; x--, d++)
        {
            if (lv[x] == '.')
            {
                d--;
                continue;
            }
            for (y=rv.size()-1, z=d; y >= 0 ; y--, z++)
            {
                if (rv[y] == '.')
                {
                    z--;
                    continue;
                }
                //printf ("lv[%d]: %c\nrv[%d]: %c\n", x, lv[x], y, rv[y]);
                m = (lv[x]-48) * (rv[y]-48);
                //printf ("m: %d\n", m);
                //printf ("tmp.size(): %d  z: %d\n", tmp.size(), z);
                while (tmp.size() <= z+1)
                    tmp.append ("0");
                tmp[z] += m%10;
                if (tmp[z] > 57)
                {
                    tmp[z] -= 10;
                    k ++;
                }
                tmp[z+1] += m/10 + k;
                k = 0;
                //printf ("tmp[%d]: %c  tmp[%d]: %c\n", z, tmp[z], z+1, tmp[z+1]);
                //cout << "tmp: "<<tmp<<"\n\n";
            }
        }
        if (k > 0)
            tmp[z+1] += k;
        tmp.insert (dot, ".");
        //cout << "tmp: " << tmp<<"\n";
        /********倒轉、刪零*******************/
        tmp = move_d_zero (tmp);// 小數點後面刪零
        tmp = string(tmp.rbegin(), tmp.rend());//倒轉
        tmp = string (move_i_zero (tmp));//整數前刪零
        if (b)
            return rounding (tmp);
        else
            return rounding (tmp, Accuracy);
    }
    static string calculate_d (string lv, string rv, bool b=true, int d=3)
    {
        clear_vstring (&lv, &rv);
        if (lv == "")
            lv = "0";
        if (rv == "")
            rv = "0";
        /*printf ("in c_d\n");
        cout << "lv: "<<lv<<"\nrv: "<<rv<<"\n";*/
        if (lv == "0")
            return ("0");
        else if (rv == "0")
            throw invalid_argument("");
        else if (rv == "1")
        {
            if (b)
                return rounding (lv);
            else
                return rounding (lv, Accuracy);
        }
        else if (lv == rv)
            return "1";
        else if ((lv[0] == '-' && rv[0] != '-') || (lv[0] != '-' && rv[0] == '-')) // -a / b || a / -b --> -(a / b)
            return calculate_s ("0", calculate_d(calculate_s("0", lv, false), rv));
        else if (lv[0] == '-' && rv[0] == '-') // -a / -b --> a / b
            return calculate_d (calculate_s("0", lv, false), calculate_s("0", rv, false));
        string tmp="", c="", v="";
        bool do_d, dot_add=false;
        int l_dot = lv.find('.'), r_dot = rv.find('.'), dot=0;
        int  x, y;

        if (l_dot != -1 && r_dot != -1) // 同乘 10 ^ n
        {
            if (lv.size()-l_dot-1 > rv.size()-r_dot-1)
                y = rv.size()-r_dot-1;
            else
                y = lv.size()-l_dot-1;
            lv.erase (l_dot, 1);
            rv.erase (r_dot, 1);
            l_dot += y;
            r_dot += y;
            if (lv.size() > l_dot)
                lv.insert (l_dot, ".");
            if (rv.size() > r_dot)
                rv.insert (r_dot, ".");
            lv = move_i_zero (lv), rv = move_i_zero (rv);
            l_dot = lv.find('.'), r_dot = rv.find('.');
        }
        if (l_dot == -1 && r_dot != -1) // int && double
        {
            y = rv.size() - r_dot - 1;
            rv.erase (r_dot, 1);
            for (x=0; x < y; x++)
                lv.append ("0");
            lv = move_i_zero (lv), rv = move_i_zero (rv);
        }
        else if (l_dot != -1 && r_dot == -1) // double && int
        {
            y = lv.size() - l_dot - 1;
            lv.erase (l_dot, 1);
            for (x=0; x < y; x++)
                rv.append ("0");
            lv = move_i_zero (lv), rv = move_i_zero (rv);
        }
#ifdef Bug
        cout << "   after 10^n\nlv: "<<lv<<"\n";
        cout << "rv: "<<rv<<"\n\n\n\n";
#endif // Bug
D:
        for (x=0, c=""; x < lv.size(); x++)
        {
            v = lv[x];

#ifdef Bug
            cout << "v: "<<v<<"\n";
#endif // Bug

            c.append (v);

#ifdef Bug
            cout << "c: "<<c<<"\n";
#endif // Bug

            v = "0";
            do_d = false;
            while (VS (c, rv) >= 0)
            {
                c = calculate_s (c, rv, false);
                v = calculate_a (v, "1");
#ifdef Bug
                cout << "c (in while): "<<c<<"\n";
                cout << "v (in while): "<<v<<"\n";
#endif // Bug
                do_d = true;
            }
#ifdef Bug
            cout << "tmp: "<<tmp<<"\n";
#endif // Bug
            if (VS (v, "0") > 0 || (v == "0" && tmp.size() > 0 && !dot_add)) // || (v == "0" && tmp.size() == 0 && dot_add)
            {
                tmp.append (v);
                if (dot_add)
                    dot_add = false;
            }
#ifdef Bug
            cout << "tmp: "<<tmp<<"\n";
#endif // Bug
            if (c == "0")
                c = "";
#ifdef Bug
            cout << "c: "<<c<<"\n\n";
#endif // Bug
        }
        if (c == lv) // 整數位數為零
            tmp.append ("0");
        lv = c;
#ifdef Bug
        cout << "lv: "<<lv<<"\n\n";
#endif // Bug
        if (dot < d && lv != "")
        {
#ifdef Bug
            cout << "           after int lv: "<<lv<<"\n\n";
#endif // Bug
            if (VS(lv, "1") >= 0)
            {
                dot_add = true;
            }
            lv = calculate_m (lv, "10", false);
#ifdef Bug
            cout << "lv: "<<lv<<"\n\n";
#endif // Bug
            dot ++;
            goto D;
        }
#ifdef Bug
        cout << "tmp: "<<tmp<<"\n";
        printf ("tmp.size(): %d   dot: %d   tmp.size()-dot: %d   tmp[%d]: %c\n", tmp.size(), dot, tmp.size()-dot, tmp.size()-dot, tmp[tmp.size()-dot]);
#endif // Bug
        x = tmp.size()-dot;
        if (x > 0 && x < tmp.size())
            tmp.insert (x, ".");
        else if (x == 0)
            tmp.insert (x, "0.");
        else if (x < 0)
        {
            while (x < 0)
            {
                tmp.insert (0, "0");
                x ++;
            }
            tmp.insert (x, "0.");
        }
#ifdef Bug
        cout << "tmp: "<<tmp<<"\n";
#endif // Bug
        tmp = string (move_zero_d(tmp));
        if (b)
            return rounding (tmp);
        else
            return rounding (tmp, Accuracy);
    }
    static string calculate_a (string lv, string rv, bool b=true)
    {
        /*printf ("       in calculate_a\n");
        cout << "in calculate_s    lv: "<<lv<<"    rv: "<<rv<<"\n";*/
        if (lv[0] == '-' && rv[0] != '-')// -a + b --> b - a
            return calculate_s (rv, (calculate_s("0", lv, false)));
        else if (lv[0] != '-' && rv[0] == '-')// a + -b --> a - b
            return calculate_s (lv, calculate_s("0", rv, false));
        else if (lv[0] == '-' && rv[0] == '-')// -a + -b --> - (a + b)
            return calculate_s ("0", calculate_a(calculate_s("0", lv, false), calculate_s("0", rv, false)));
        string tmp="", c="";
        int x, y, z;
        add_zero (&lv, &rv); // 補零
        /***********運算*******************/
        for (x=lv.size()-1, y=0, z=0; x >= 0 ; x--, z++)
        {
            if (lv[x] == '.')
            {
                c = lv[x];
                tmp.append(c);
                continue;
            }
            c = lv[x] + rv[x] - 48 + y;
            tmp.append(c);
            y=0;
            if (tmp[z] > 57)
            {
                tmp[z] -= 10;
                y = 1;
            }
        }
        if (y > 0)
            tmp.append ("1");
        /********倒轉、刪零*******************/
        tmp = move_d_zero (tmp);// 小數點後面刪零
        tmp = string (tmp.rbegin(), tmp.rend());
        if (b)
            return rounding (tmp);
        else
            return rounding (tmp, Accuracy);
    }
    static string calculate_s (string lv, string rv, bool b=true)
    {
        clear_vstring (&lv, &rv);
        if (lv == "")
            lv = "0";
        if (rv == "")
            rv = "0";
        //cout << "in calculate_s    lv: "<<lv<<"    rv: "<<rv<<"\n";
        if (lv == rv)
            return "0";
        else if (lv == "0")
        {
            if (rv[0] != '-')
            {
                lv.assign ("-");
                lv.append (rv);
                return lv;
            }
            lv = string (rv.substr(1));
            return lv;
        }
        if (lv[0] == '-' && rv[0] != '-')// -a - b --> - (a + b)
            return calculate_s ("0", calculate_a(calculate_s("0", lv, false), rv));
        else if (lv[0] != '-' && rv[0] == '-')// a - -b --> a + b
            return calculate_a (lv, calculate_s("0", rv, false));
        else if (lv[0] == '-' && rv[0] == '-')// -a - -b --> b - a
            return calculate_s (calculate_s("0", rv, false), calculate_s("0", lv, false));
        else if (VS(lv, rv) == -1)// a - b (a < b) --> -(b - a)
            return calculate_s ("0", calculate_s(rv, lv));
        string tmp="", c="";
        int x, y, z;
        add_zero (&lv, &rv); // 補零
        /***********運算*******************/
        for (x=lv.size()-1, y=0, z=0; x >= 0; x--)
        {
            if (lv[x] == '.')
            {
                tmp.append (".");
                continue;
            }
            lv[x] += y;
            y = 0;
            if (lv[x] < rv[x])
            {
                lv[x] += 10;
                y = -1;
            }
            c = lv[x] - rv[x] + 48;
            tmp.append (c);
        }
        /********倒轉、刪零*******************/
        tmp = move_d_zero (tmp);// 小數點後面刪零
        tmp = string(tmp.rbegin(), tmp.rend());//倒轉
        tmp = move_i_zero (tmp);//整數前刪零
        if (tmp == "")
            tmp.append ("0");
        if (b)
            return rounding (tmp);
        else
            return rounding (tmp, Accuracy);
    }
    static void clear_vstring (string *lv, string *rv)
    {
        *lv = move_i_zero (*lv), *rv = move_i_zero (*rv);
        *lv = move_zero_d (*lv), *rv = move_zero_d (*rv);
    }
    static int VS (string lv, string rv)
    {
        clear_vstring (&lv, &rv);
        /*if (lv == "0")
        {
            cout << "\n   in VS:\n";
            cout << "lv: "<<lv<<"\nrv: "<<rv<<endl;
        }*/

        int l_dot = lv.find('.'), r_dot = rv.find('.'), x;
        if (l_dot == -1)
            l_dot = lv.size();
        if (r_dot == -1)
            r_dot = rv.size();

        if (l_dot > r_dot) //lv > rv
            return 1;
        else if (l_dot < r_dot) //lv < rv
            return -1;
        for (x=0; x < lv.size() && x < rv.size() && lv[x] == rv[x] ; x++);
        if (x == lv.size() && x == rv.size())
            return 0;
        if ((x == rv.size() && x < lv.size()) || lv[x] > rv[x])
            return 1;
        else if ((x == lv.size() && x < rv.size()) || lv[x] < rv[x])
            return -1;
    }
    static string add_i_zero (string v, int d)
    {
        string tmp="";
        int x;
        for (x=0; x < d; x++)
            tmp.append ("0");
        tmp.append (v);
        return tmp;
    }
    static string add_zero_d (string v, int i, int f, bool no_dot)
    {
        if (no_dot)
        {
            v.append (".");
            i ++;
        }
        for (; i < f; i++)
            v.append ("0");
        return v;
    }
    static string move_i_zero (string v)
    {
        int x;
        for (x=0; x < v.size() && v[x] == '0' ; x++);
        if (v[x] == '.')
            x--;
        return string (v.substr(x));
    }
    static string move_d_zero (string v) // v 倒敘
    {
        int x;
        if (v.find('.') == -1) // 沒有小數
            return v;
        for (x=0; v[x] != '.' && v[x] == '0' ; x++);
        if (v[x] == '.') //小數點後都是零
            v = string (v.substr(x+1));
        else
            v = string (v.substr(x));
        return v;
    }
    static string move_zero_d (string v)
    {
        string tmp = move_d_zero (string(v.rbegin(), v.rend()));
        return string(tmp.rbegin(), tmp.rend());
    }
    static void add_zero (string *lv, string *rv)
    {
        int l_dot = lv->find('.'), r_dot = rv->find('.'), dot;
        if (l_dot == -1)
            l_dot = lv->size();
        if (r_dot == -1)
            r_dot = rv->size();
        /*******補零*********/
        if (l_dot > r_dot)// 整數
        {
            *rv = add_i_zero (*rv, l_dot-r_dot);
            dot = l_dot;
        }
        else if (l_dot < r_dot)
        {
            *lv = add_i_zero (*lv, r_dot-l_dot);
            dot = r_dot;
        }
        else
            dot = l_dot;
        if (lv->size() > rv->size())//小數
            *rv = add_zero_d (*rv, rv->size(), lv->size(), rv->size() == dot);
        else if (lv->size() < rv->size())
            *lv = add_zero_d (*lv, lv->size(), rv->size(), lv->size() == dot);
    }
    static string rounding (string str, int d=3)
    {
        /*cout << "str.size(): "<<str.size()<<"\n";
        cout << "str[str.size()]: "<<str[str.size()]<<"\n";
        cout << "str[str.size()-dot]: "<<str[str.size()-dot]<<"\n";*/
        int dot = str.find ('.');
        if (dot == -1 || str.size()-dot-1 < d)
            return str;
        /*printf ("   ");
        cout << "str: "<<str<<"\n";
        cout << "str[dot+2]: "<<str[dot+2]<<"\n";
        cout << "str[dot+3]: "<<str[dot+3]<<"\n";*/
        if ((str[dot+d] > '5') || (str[dot+d] == '5' && (str[dot+d-1]-48)%2 == 1)) // || (str[dot+d] == '5' && str.size()-dot > d)
        {
            str = str.substr (0, dot+d);
            if (d == 3)
                str = calculate_a (str, "0.01");
            else if (d == Accuracy)
                str = calculate_a (str, "0.000000000000001", false);
            else if (d == 9)
                str = calculate_a (str, "0.00000001", false);
        }
        else
            str = str.substr (0, dot+d);
        //cout << "str: "<<str<<"\n";
        return str;
    }
};


class BigDecimal
{
private:
    LinkedList<string> *integer;
    LinkedList<string> *decimal;
public:
    BigDecimal()
    {
        integer = new LinkedList<string>();
        decimal = new LinkedList<string>();
    }
    BigDecimal(string data)
    {
        integer = new LinkedList<string>();
        decimal = new LinkedList<string>();
        int x;
        string tmp="";
        x = data.find ('.');
        if (x == -1)//沒有小數
            integer->addToTail(data);
        else
        {
            tmp = data.substr (0, x);
            integer->addToHead(tmp);
            tmp = data.substr (x+1);
            decimal->addToHead(tmp);
        }
    }
    BigDecimal* operator+(BigDecimal *bigDecimal)
    {
        try
        {
        string lv, rv;
        BigDecimal*ans;
        to_string (&lv, &rv, bigDecimal);
        ans = new BigDecimal (Formula::calculate_a (lv, rv));
        return ans;
        }
        catch (invalid_argument &e)
        {
            throw invalid_argument ("");
        }
    }
    BigDecimal* operator-(BigDecimal *bigDecimal)
    {
        try
        {
        string lv, rv;
        BigDecimal*ans;
        to_string (&lv, &rv, bigDecimal);
        ans = new BigDecimal (Formula::calculate_s (lv, rv));
        return ans;
        }
        catch (invalid_argument &e)
        {
            throw invalid_argument ("");
        }
    }
    BigDecimal* operator*(BigDecimal *bigDecimal)
    {
        try
        {
        string lv, rv;
        BigDecimal*ans;
        to_string (&lv, &rv, bigDecimal);
        ans = new BigDecimal (Formula::calculate_m (lv, rv));
        return ans;
        }
        catch (invalid_argument &e)
        {
            throw invalid_argument ("");
        }
    }
    BigDecimal* operator/(BigDecimal *bigDecimal)
    {
        try
        {
        string lv, rv;
        BigDecimal*ans;
        to_string (&lv, &rv, bigDecimal);
        ans = new BigDecimal (Formula::calculate_d (lv, rv));
        return ans;
        }
        catch (invalid_argument &e)
        {
            throw invalid_argument ("");
        }
    }
    BigDecimal* operator^(BigDecimal *bigDecimal)
    {
        try
        {
        string lv, rv;
        bool dot=false;
        BigDecimal *ans;
        to_string (&lv, &rv, bigDecimal);
        if (rv.find('.') != -1)
            dot = true;
        /*cout << "lv: "<<lv<<"\n";
        cout << "rv: "<<rv<<"\n";*/
        if (dot)
            ans = new BigDecimal (Formula::calculate_p_d (lv, rv));
        else
            ans = new BigDecimal (Formula::calculate_p_i (lv, rv));
        return ans;
        }
        catch (invalid_argument &e)
        {
            throw invalid_argument ("");
        }
    }
    LinkedList<string> *get_integer () const
    {
        return (LinkedList<string> *)integer;
    }
    LinkedList<string> *get_decimal () const
    {
        return (LinkedList<string> *)decimal;
    }
    void show () const
    {
        cout << integer->get_head()->get_data();
        if (decimal->get_head() == NULL)
            return;
        cout << "." <<decimal->get_head()->get_data();
        return;
    }
    void to_string (string *lv, string *rv, BigDecimal *bigDecimal)
    {
        *lv = this->get_integer()->get_head()->get_data();
        if (this->get_decimal()->get_head() != NULL)
        {
            lv->append (".");
            lv->append (this->get_decimal()->get_head()->get_data());
        }
        *rv = bigDecimal->get_integer()->get_head()->get_data();
        if (bigDecimal->get_decimal()->get_head() != NULL)
        {
            rv->append (".");
            rv->append (bigDecimal->get_decimal()->get_head()->get_data());
        }
        Formula::clear_vstring (lv, rv);
    }
    friend std::ostream &operator<<(std::ostream &out, BigDecimal *bigDecimal)
    {
        if (bigDecimal->get_integer()->get_head() == NULL)
        {
            out << "NULL\n";
            return out;
        }
        out << bigDecimal->get_integer()->get_head()->get_data();
        if (bigDecimal->get_decimal()->get_head() == NULL)
        {
            out << ".00\n";
            return out;
        }
        string tmp = bigDecimal->get_decimal()->get_head()->get_data();
        if (tmp.size() >= 2)
            out << "." << tmp[0] << tmp[1]<<endl;
        else if (tmp.size() == 1)
            out << "." << tmp << "0"<<endl;
        return out;
    }
    friend std::istream &operator>>(std::istream &in, BigDecimal *data)
    {
        #ifdef Mem
        printf ("           in operator>>\n");
        #endif // Mem
        Node<string> *tmp=NULL;
        while (data->get_integer()->get_head() != NULL)
        {
        #ifdef Mem
            printf ("data->get_integer()->get_head() != NULL\n");
            cout << "show linked list --- data->get_integer(): " << data->get_integer()<<endl;
        #endif // Mem
            tmp = data->get_integer()->deleteFromHead();
           /* printf ("i    %p\n", tmp);
            cout << tmp->get_data()<<endl;*/
            delete tmp;
        }
        while (data->get_decimal()->get_head() != NULL)
        {
        #ifdef Mem
            printf ("data->get_decimal()->get_head() != NULL\n");
            cout << "show linked list --- data->get_decimal(): " << data->get_decimal()<<endl;
        #endif // Mem
            tmp = data->get_decimal()->deleteFromHead();
           /* printf ("d    %p\n", tmp);
            cout << tmp->get_data()<<endl;*/
            delete tmp;
        }
        string d;
        in >> d;
        #ifdef Mem
        cout << "--> in >> d: "<< d<<"\n";
        #endif // Mem
        BigDecimal b(d);

        data->get_integer()->addToHead(b.get_integer()->get_head()->get_data());
        tmp = b.get_integer()->deleteFromHead();
        delete tmp;
        #ifdef Mem
        printf ("--> tmp = b.get_integer()->deleteFromHead()\n--> delete tmp\n");
        #endif // Mem
        if (b.get_decimal()->get_head() != NULL)
        {
            data->get_decimal()->addToHead(b.get_decimal()->get_head()->get_data());
            tmp = b.get_decimal()->deleteFromHead();
            delete tmp;
        #ifdef Mem
        printf ("--> tmp = b.get_decimal()->deleteFromHead()\n--> delete tmp\n");
        #endif // Mem
        }
        return in;
    }
};

string calculate (Stack<string> *S, char operation)
{
    //printf ("in calculate\n");
    BigDecimal *lv, *rv, *tmp;
    string ans="";
    //S->show();
    try
    {
        rv = new BigDecimal (S->pop());
        lv = new BigDecimal (S->pop());
      //  cout << "lv: " << lv << "\nrv: " << rv <<"\n";
        switch (operation)
        {
        case '+':
            tmp = (*lv + rv);
            break;
        case '-':
            tmp = (*lv - rv);
            break;
        case '*':
            tmp = (*lv * rv);
            break;
        case '/':
            tmp = (*lv / rv);
            break;
        case '^':
            tmp = (*lv ^ rv);
            break;
        default:
            throw invalid_argument("");
            break;
        }
        delete lv->get_integer()->deleteFromHead();
        if (lv->get_decimal()->get_head() != NULL)
            delete lv->get_decimal()->deleteFromHead();
        delete rv->get_integer()->deleteFromHead();
        if (rv->get_decimal()->get_head() != NULL)
            delete rv->get_decimal()->deleteFromHead();
        ans = tmp->get_integer()->get_head()->get_data();
        delete tmp->get_integer()->deleteFromHead();
        if (tmp->get_decimal()->get_head() != NULL)
        {
            ans.append (".");
            ans.append (tmp->get_decimal()->get_head()->get_data());
        delete tmp->get_decimal()->deleteFromHead();
        }
        //cout << "ans: "<<ans<<"\n\n";

        return ans;
    }
    catch (invalid_argument &e)
    {
        throw invalid_argument("");
    }
}

int main()
{
    int x, y, z, l, dot;
    string question="", postfix="", c="", ans="";
    Stack<string> S;

    while (cin>>question)
    {
        question.insert (0, "(");
        question.insert (question.size(), ")");
        ans = c = postfix = "";
        l = question.size();
        //cout << question << endl;
        for (z=0; z < l; z++, l = question.size())
            for (x=0; x < l; x++) // 負號轉減法
                if (question[x] == '-' && (x-1 < 0 || ((question[x-1]+2)/10 != 5) && question[x-1] != ')') && x+1 < l && (question[x+1]+2)/10 == 5 && x-1 >= 0 && (question[x-1]+2)/10 != 5)
                {
                    question.insert (x, "(0");
                    l += 2;
                    /*printf ("question[x]: %c\n", question[x]);
                    printf ("question[x+1]: %c\n", question[x+1]);
                    printf ("question[x+2]: %c\n", question[x+2]);
                    printf ("question[x+3]: %c\n", question[x+3]);*/
                    for (y=x+3; y < l+2 && ((question[y]+2)/10 == 5 || question[y] == '.') ; y++);
                    //printf ("question[y]: %c\n", question[y]);
                    question.insert (y, ")");
                    //cout << question << endl;
                }
        l = question.size();
        //cout << question << endl;
        try
        {
            for (x=0; x < l ; x++) // 中序轉後序
            {
                //printf ("%c\n", question[x]);
                if (((question[x]+2)/10) == 5 || question[x] == '.') // 數字
                {
                    c = question[x];
                    postfix.append (c);
                }//非數字
                else if (question[x] == '(')// 左括號直接丟
                {
                    c = question[x];
                    S.push(c);
                }
                else if (question[x] == '^') //運算子
                {
                    postfix.append (" ");
                    c = question[x];
                    S.push(c);
                }
                else if (question[x] == '*' || question[x] == '/') //運算子
                {
                    if (S.top() == "^" || S.top() == "*" || S.top() == "/")
                        postfix.append (S.pop());
                    postfix.append (" ");
                    c = question[x];
                    S.push(c);
                }
                else if (question[x] == '+' || question[x] == '-') //運算子
                {
                    if (S.top() == "^" || S.top() == "*" || S.top() == "/" || S.top() == "+" || S.top() == "-")
                        postfix.append (S.pop());
                    postfix.append (" ");
                    c = question[x];
                    S.push(c);
                }
                else if (question[x] == ')')
                {
                    while (S.top() != "(")
                        postfix.append (S.pop());
                    S.pop();
                    /*cout << "postfix: " << postfix << endl;
                    S.show();*/
                }
                else
                {
                    //printf ("x=%d --> (%c)\n", x, question[x]);
                    goto ERROR;
                }
            }
        }
        catch (invalid_argument &e)
        {
            goto ERROR;
        }
         /*S.show();
         cout << "~postfix: " << postfix << endl;*/
        l = postfix.size();
        question = "";
        c = "";
        for (x=0; x < l; x++) // 計算
        {
            if (postfix[x] == ' ' || postfix[x] == '^' || postfix[x] == '*' || postfix[x] == '/' || postfix[x] == '+' || postfix[x] == '-')
            {
                if (question != "")
                    S.push (question);
                question = "";
                if (postfix[x] == '^' || postfix[x] == '*' || postfix[x] == '/' || postfix[x] == '+' || postfix[x] == '-')
                {
                    try
                    {
                        S.push (calculate (&S, postfix[x]));
                        //S.show();
                    }
                    catch (invalid_argument &e)
                    {
                        goto ERROR;
                    }
                }
            }
            else if ((postfix[x]+2)/10 == 5)
            {
                c = postfix[x];
                question.append (c);
            }
            else if (postfix[x] == '.' && x > 0 && (postfix[x-1]+2)/10 == 5 && x < l-1 && (postfix[x+1]+2)/10 == 5)
            {
                c = postfix[x];
                question.append (c);
            }
            else
            {
                //printf ("x=%d --> (%c)\n", x, postfix[x]);
                goto ERROR;
            }
        }

        try
        {
            ans = S.pop();
            ans = Formula::rounding(ans);
            dot = ans.find('.');
            if (dot == -1)
                ans.append (".00");
            else if (dot != -1 && ans.size()-dot-1 < 2)
                ans.append ("0");
            cout << ans << endl;
            /* S.show();
             printf ("\n\n\n");*/
        }
        catch (invalid_argument &e)
        {
            goto ERROR;
        }


        if (0)
        {
ERROR:
            cout << "ERROR\n";
            while (!S.isEmpty())
                S.pop();
        }
    }
    return 0;
}
